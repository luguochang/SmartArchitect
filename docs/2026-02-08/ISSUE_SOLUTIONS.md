# Issue Solutions - 生产问题记录与解决方案

本文档记录项目开发和生产过程中遇到的关键问题及其解决方案，用于积累经验和快速排查类似问题。

---

## Issue #1: Excalidraw 流式生成 JSON 解析失败导致连接中断

**日期**: 2026-01-18
**严重程度**: 高（导致功能完全失效）
**影响范围**: Excalidraw 场景生成功能（流式和非流式）

### 问题描述

用户使用 Excalidraw 生成流程图时，后端返回 500 错误，前端提示 `socket hang up (ECONNRESET)`。

**错误日志**:
```
[2026-01-18 11:26:41] [WARNING] JSON decode failed: Expecting ',' delimiter: line 469 column 6 (char 10598)
[2026-01-18 11:26:41] [ERROR] All JSON repair strategies failed
[2026-01-18 11:26:41] [ERROR] Streaming generation failed: Empty scene returned by AI
```

**前端错误**:
```
Failed to proxy http://localhost:8000/api/chat-generator/generate-stream
Error: socket hang up (ECONNRESET)
```

### 根因分析

#### 问题链条

1. **AI 返回格式不完整**: AI 生成了 10965 字符的 JSON，但在第 469 行缺少逗号分隔符
2. **JSON 解析失败**: `json.loads()` 抛出 `JSONDecodeError: Expecting ',' delimiter`
3. **修复策略不足**: 所有 4 个 JSON 修复策略都失败
   - 策略 1: 简单的 `}\s*{` → `}, {` 替换无法处理跨行情况
   - 策略 2-4: 未覆盖大型 JSON 中间缺少逗号的情况
4. **返回空字典**: `_safe_json()` 在所有策略失败后返回 `{}`
5. **下游误判**: `_validate_scene()` 接收空字典，`elements` 为空列表
6. **抛出异常**: 流式接口检测到 `scene.elements` 为空，抛出 `ValueError`
7. **连接中断**: 异常发生时流已部分发送，导致前端 socket 中断

#### 核心问题

1. **JSON 修复逻辑不够健壮**
   - 未处理跨行的缺少逗号情况（`}\n{`）
   - 未处理数字/布尔值后缺少逗号的情况（`100 "key"`）

2. **错误处理链条脆弱**
   - 修复失败后返回空字典而非抛出异常
   - 下游逻辑将空字典当作有效输入处理
   - 空场景检查在流已发送部分数据后才触发

3. **缺少 Fallback 机制**
   - 未在合适的位置返回 mock 数据
   - 异常抛出时机过晚，流已部分发送

### 解决方案

#### 1. 增强 JSON 修复逻辑

**文件**: `backend/app/services/excalidraw_generator.py:199-221`

```python
# 改进前
text_with_commas = re.sub(r'}\s*{', '}, {', text)
text_with_commas = re.sub(r'"\s+"', '", "', text_with_commas)

# 改进后 - 处理更多边缘情况
text_with_commas = re.sub(r'}\s+{', '}, {', text)           # 多个空白符
text_with_commas = re.sub(r'}\n\s*{', '},\n{', text_with_commas)  # 跨行
text_with_commas = re.sub(r'"\s*\n\s*"', '",\n"', text_with_commas)  # 换行的属性
text_with_commas = re.sub(r'(\d+)\s+(")', r'\1, \2', text_with_commas)  # 数字后
text_with_commas = re.sub(r'(true|false|null)\s+(")', r'\1, \2', text_with_commas)  # 布尔值后
```

**覆盖场景**:
- ✅ `} {` → `}, {` (同行)
- ✅ `}\n{` → `},\n{` (跨行)
- ✅ `100 "key"` → `100, "key"` (数字后缺逗号)
- ✅ `true "key"` → `true, "key"` (布尔值后缺逗号)

#### 2. 修改错误返回值

**文件**: `backend/app/services/excalidraw_generator.py:285-292`

```python
# 改进前
logger.error(f"All JSON repair strategies failed. Raw payload: {payload[:200]}...")
return {}  # ❌ 返回空字典导致下游误判

# 改进后
logger.error(f"All JSON repair strategies failed. Payload length: {len(payload)}")
logger.error(f"First 500 chars: {payload[:500]}")
logger.error(f"Last 500 chars: {payload[-500:]}")
return None  # ✅ 返回 None 触发 fallback
```

#### 3. 在验证层添加 Fallback

**文件**: `backend/app/services/excalidraw_generator.py:307-310`

```python
def _validate_scene(self, ai_data: dict, width: int, height: int) -> ExcalidrawScene:
    # 新增：处理 None 或无效输入
    if ai_data is None or not isinstance(ai_data, dict):
        logger.warning("Invalid ai_data provided to _validate_scene, returning mock scene")
        return self._mock_scene()
    # ...
```

**文件**: `backend/app/services/excalidraw_generator.py:455-460`

```python
# 新增：清理后如果无有效元素，返回 mock
if not cleaned:
    logger.warning("No valid elements after cleaning, returning mock scene")
    mock = self._mock_scene()
    mock.appState["message"] = "AI generated invalid elements, showing fallback scene"
    return mock
```

#### 4. 移除下游空场景检查

**文件**: `backend/app/api/excalidraw.py:110-129`

```python
# 删除了这段代码（第 115-116 行）
if not scene.elements:
    raise ValueError("Empty scene returned by AI")

# 因为 _validate_scene 现在保证返回有效场景（AI 或 mock）
```

**文件**: `backend/app/services/excalidraw_generator.py:615-624`

```python
# 改进前
scene = self._validate_scene(ai_data, width, height)
scene.appState["message"] = f"Generated via {provider}"
if not scene.elements:  # ❌ 不再需要这个检查
    raise ValueError("Empty scene generated by AI")
return scene

# 改进后
scene = self._validate_scene(ai_data, width, height)
# 只在非 fallback 场景更新消息
current_message = scene.appState.get("message", "")
if "fallback" not in current_message.lower() and "mock" not in current_message.lower():
    scene.appState["message"] = f"Generated via {provider}"
return scene  # ✅ 保证有元素（AI 或 mock）
```

### 效果验证

#### 修复前
```
Input: "画一个github每次提交的热力图"
→ AI 返回: 10965 字符（line 469 缺逗号）
→ JSON 解析失败
→ 返回 {}
→ elements = []
→ 抛出异常
→ 前端 socket hang up
```

#### 修复后
```
Input: "画一个github每次提交的热力图"
→ AI 返回: 10965 字符（line 469 缺逗号）
→ JSON 修复成功（跨行逗号插入）
→ 解析为有效场景
✅ 前端正常显示

OR (如果修复仍失败)
→ _safe_json 返回 None
→ _validate_scene 检测到 None
→ 返回 mock 场景（猫脸）
✅ 前端显示 fallback 提示
```

### 关键经验

1. **多层防御**: JSON 解析 → 修复 → Fallback → Mock，每层都有保护
2. **明确契约**: 返回 `None` 比返回空结构更明确地表达"失败"
3. **早期 Fallback**: 在数据验证层而非业务层返回 mock
4. **流式安全**: 流式接口必须保证在发送任何数据前验证完整性
5. **详细日志**: 记录首尾 500 字符帮助快速定位 JSON 错误位置

### 相关文件

- `backend/app/services/excalidraw_generator.py` (JSON 修复逻辑)
- `backend/app/api/excalidraw.py` (流式接口)
- `frontend/lib/excalidrawUtils.ts` (前端解析工具)

### 预防措施

#### 开发阶段
- [ ] 为 `_safe_json` 添加单元测试（覆盖各种畸形 JSON）
- [ ] 为流式接口添加集成测试（模拟各种失败场景）
- [ ] 添加 JSON 修复成功率监控

#### 生产阶段
- [ ] 记录所有 JSON 解析失败的完整 payload（用于改进修复策略）
- [ ] 监控 mock 场景返回率（超过 10% 需要优化 prompt）
- [ ] 添加 AI provider 健康检查（检测输出质量）

---

## Issue #2: 前端缺少 excalidrawUtils 模块

**日期**: 2026-01-18
**严重程度**: 高（构建失败）
**影响范围**: 前端 Excalidraw 功能

### 问题描述

前端构建失败，错误信息：
```
Module not found: Can't resolve '@/lib/excalidrawUtils'
Import trace:
  ./components/ArchitectCanvas.tsx
  ./components/ExcalidrawBoard.tsx
```

### 根因分析

- `ExcalidrawBoard.tsx` 在第 7 行导入 `sanitizeExcalidrawData`
- `useArchitectStore.ts` 在第 719 行动态导入 `safeParsePartialJson`
- 但 `frontend/lib/excalidrawUtils.ts` 文件缺失

### 解决方案

创建 `frontend/lib/excalidrawUtils.ts` 文件，实现以下功能：

1. **sanitizeExcalidrawData**: 验证和清理 Excalidraw 场景数据
   - 检查必需字段 (id, type, x, y, width, height, version)
   - 验证元素类型有效性
   - 过滤无效元素
   - 添加默认 appState

2. **safeParsePartialJson**: 安全解析部分 JSON
   - 处理不完整 JSON 字符串
   - 自动补全缺失的闭合括号
   - 移除 markdown 代码块标记
   - 支持截断式解析

3. **isValidExcalidrawScene**: 验证场景结构

### 效果验证

- ✅ 前端构建成功
- ✅ Excalidraw 组件正常加载
- ✅ 流式解析实时更新

---

## Issue #3: Excalidraw 流式生成因错误模型名导致 API 调用失败

**日期**: 2026-01-18
**严重程度**: 高（功能完全失效）
**影响范围**: Excalidraw 流式场景生成

### 问题描述

Excalidraw 流式生成一直失败，而 FlowCanvas 的流式生成正常工作。前端没有看到流式输出，加载几秒后直接报错。

**错误堆栈**:
```python
File "ai_vision.py", line 768, in generate_with_stream
    raise data
File "ai_vision.py", line 741, in _custom_stream
    stream = self.client.chat.completions.create(
        model=self.custom_model_name or "gpt-3.5-turbo",  # ❌ 错误的模型名
        ...
    )
# OpenAI client 抛出异常（模型不存在或不支持）
```

### 根因分析

#### 代码对比

**FlowCanvas (chat_generator) - 工作正常**:
```python
# backend/app/api/chat_generator.py:121-127
stream = vision_service.client.chat.completions.create(
    model=vision_service.model_name,  # ✅ 使用正确的 model_name
    messages=[{"role": "user", "content": prompt}],
    stream=True,
    ...
)
for chunk in stream:  # 直接同步迭代
    # 处理 chunk
```

**Excalidraw - 失败**:
```python
# backend/app/api/excalidraw.py:100
async for token in vision_service.generate_with_stream(prompt):
    # 调用了抽象方法

# backend/app/services/ai_vision.py:741-742
stream = self.client.chat.completions.create(
    model=self.custom_model_name or "gpt-3.5-turbo",  # ❌ 错误！
    ...
)
```

#### 问题链条

1. **用户配置**:
   - Provider: `custom`
   - Base URL: `https://www.linkflow.run/v1`
   - Model: `claude-sonnet-4-5-20250929`

2. **AIVisionService 初始化**:
   ```python
   # ai_vision.py:53-61
   self.custom_model_name = model_name  # 可能为 None
   self.model_name = model_name or default_model  # 保证有值
   ```

3. **generate_with_stream 调用**（自定义 provider）:
   ```python
   # ai_vision.py:741-742
   stream = self.client.chat.completions.create(
       model=self.custom_model_name or "gpt-3.5-turbo",  # ❌ 使用错误字段
       ...
   )
   ```

4. **结果**:
   - 如果 `custom_model_name` 传入了正确值 → 正常工作
   - 如果 `custom_model_name` 为 `None` → 回退到 `"gpt-3.5-turbo"`
   - 自定义 API（linkflow.run）不支持 `gpt-3.5-turbo` → 抛出异常
   - 前端连接中断

#### 核心问题

1. **字段混淆**:
   - `self.custom_model_name` - 可选，仅存储传入值
   - `self.model_name` - 必需，保证有默认值
   - 代码错误使用了前者而非后者

2. **缺少日志**:
   - 无法看到实际发送的模型名
   - 无法追踪流式调用的各个阶段
   - 错误堆栈不包含关键参数信息

3. **调用方式不一致**:
   - FlowCanvas 直接调用 `client.chat.completions.create`
   - Excalidraw 调用抽象方法 `generate_with_stream`
   - 抽象方法有 bug 但 FlowCanvas 绕过了它

### 解决方案

#### 1. 修复模型名使用

**文件**: `backend/app/services/ai_vision.py:743`

```python
# 改进前
stream = self.client.chat.completions.create(
    model=self.custom_model_name or "gpt-3.5-turbo",  # ❌ 错误字段
    ...
)

# 改进后
stream = self.client.chat.completions.create(
    model=self.model_name,  # ✅ 使用 self.model_name（保证有值）
    ...
)
```

**影响范围**: `custom` provider 的流式调用

#### 2. 添加详细日志

**位置 1**: API 入口层 (`backend/app/api/excalidraw.py`)

```python
logger.info(f"[EXCALIDRAW-STREAM] Starting generation")
logger.info(f"[EXCALIDRAW-STREAM] Provider: {request.provider}, Model: {request.model_name}")
logger.info(f"[EXCALIDRAW-STREAM] Prompt: {request.prompt[:100]}...")
logger.info(f"[EXCALIDRAW-STREAM] Vision service created: provider={vision_service.provider}, model={vision_service.model_name}")
logger.info(f"[EXCALIDRAW-STREAM] Starting AI streaming...")
logger.info(f"[EXCALIDRAW-STREAM] Streaming completed: {len(accumulated)} characters, {token_count} tokens")
```

**位置 2**: 服务层 (`backend/app/services/ai_vision.py`)

```python
# Custom provider
logger.info(f"[STREAM] Custom provider streaming with model: {self.model_name}")
logger.info(f"[STREAM] Initiating stream with base_url={self.custom_base_url}, model={self.model_name}")
logger.info("[STREAM] Stream created successfully, starting to iterate chunks")
logger.info("[STREAM] Stream iteration completed successfully")
logger.error(f"[STREAM] Exception in _custom_stream: {e}", exc_info=True)
```

类似日志也添加到了：
- OpenAI provider
- SiliconFlow provider
- Claude provider

#### 3. 统一调用方式（可选优化）

**问题**: FlowCanvas 和 Excalidraw 使用不同的调用方式

**建议**:
- 方案 A: 统一使用 `generate_with_stream`（需要确保所有 provider 都正确实现）
- 方案 B: 统一直接调用 `client.chat.completions.create`（绕过抽象层）

**当前**: 已修复 `generate_with_stream` 方法，两种调用方式都可正常工作

### 效果验证

#### 修复前
```
Excalidraw 调用流式 API
→ generate_with_stream(prompt)
→ model="gpt-3.5-turbo" (错误)
→ linkflow.run API 不支持该模型
→ 抛出异常
→ 前端 socket hang up
```

#### 修复后
```
Excalidraw 调用流式 API
→ generate_with_stream(prompt)
→ model="claude-sonnet-4-5-20250929" (正确)
→ linkflow.run API 正常响应
→ 流式返回 JSON 数据
→ 前端实时显示 ✅
```

### 日志示例

**修复后的完整日志流**:
```
[EXCALIDRAW-STREAM] Starting generation
[EXCALIDRAW-STREAM] Provider: custom, Model: claude-sonnet-4-5-20250929
[EXCALIDRAW-STREAM] Prompt: 画一个github每次提交的热力图...
[EXCALIDRAW-STREAM] Vision service created: provider=custom, model=claude-sonnet-4-5-20250929
[EXCALIDRAW-STREAM] Prompt built, length: 1542
[EXCALIDRAW-STREAM] Starting AI streaming...
[STREAM] Custom provider streaming with model: claude-sonnet-4-5-20250929
[STREAM] Initiating stream with base_url=https://www.linkflow.run/v1, model=claude-sonnet-4-5-20250929
[STREAM] Stream created successfully, starting to iterate chunks
[STREAM] Stream iteration completed successfully
[EXCALIDRAW-STREAM] Streaming completed: 8542 characters, 856 tokens
```

### 关键经验

1. **字段命名要清晰**: `custom_model_name` vs `model_name` 容易混淆
2. **默认值要保证**: 永远使用有默认值的字段而非可选字段
3. **日志要分层**: API 层 + 服务层 + 方法内部，三层日志覆盖
4. **对比分析很重要**: "为什么 A 能工作但 B 不能"是快速定位问题的关键
5. **模型名很关键**: AI API 调用失败最常见原因就是模型名错误

### 相关文件

- `backend/app/services/ai_vision.py` (修复模型名 + 添加日志)
- `backend/app/api/excalidraw.py` (添加入口日志)
- `backend/app/api/chat_generator.py` (对比参考)

### 预防措施

#### 代码层面
- [ ] 重构 `AIVisionService`，统一使用 `self.model_name`
- [ ] 移除 `self.custom_model_name` 字段（减少混淆）
- [ ] 为所有 provider 添加单元测试（模拟流式调用）

#### 运维层面
- [ ] 监控 AI API 调用失败率（按 provider 分组）
- [ ] 记录所有模型名验证失败的情况
- [ ] 添加模型名白名单检查（启动时验证）

---

## Issue #4: Excalidraw 前端性能问题导致页面崩溃

**日期**: 2026-01-18
**严重程度**: 致命（页面完全崩溃）
**影响范围**: Excalidraw 流式生成前端

### 问题描述

Excalidraw 流式生成时：
1. 页面一直加载，没有返回结果
2. 最后浏览器提示"此页面存在问题"崩溃
3. 没有看到流式打印效果
4. 但后端测试显示 API 正常（能收到 1134 个 events）

### 根因分析

#### 致命问题 1: 循环中动态导入模块

**文件**: `frontend/lib/store/useArchitectStore.ts:719`

```typescript
if (content.startsWith("[TOKEN]")) {
    const token = content.replace("[TOKEN]", "").trimStart();
    accumulatedJson += token;

    // ❌ 每个 token 都会动态导入一次！
    const { safeParsePartialJson, sanitizeExcalidrawData } = await import("@/lib/excalidrawUtils");

    // ... 解析逻辑
}
```

**影响**:
- 如果收到 1134 个 tokens → **动态导入 1134 次**
- 每次导入都会：
  - 创建新的模块实例
  - 分配内存
  - 执行模块代码
- 结果：**内存爆炸 + CPU 100% + 页面崩溃**

#### 致命问题 2: 每个 Token 都打印日志

**文件**: `frontend/lib/store/useArchitectStore.ts:729`

```typescript
console.log(`[Streaming] Accumulated ${accumulatedJson.length} chars, trying to parse...`);
```

**影响**:
- 1134 个 tokens = **1134 行日志**
- 控制台被刷爆
- 性能进一步降低

#### 致命问题 3: 每个 Token 都更新状态

```typescript
// 每个 token 都会：
1. 正则匹配 (CPU 密集)
2. JSON 解析 (CPU + 内存密集)
3. 数据验证 (CPU 密集)
4. 状态更新 (触发 React 重渲染)
5. Excalidraw 组件重绘 (GPU 密集)
```

**频率**: 1134 次/次生成
**结果**: 浏览器主线程完全阻塞

#### 为什么 FlowCanvas 没问题？

FlowCanvas 只收到 159 个 events，而且：
1. 没有动态导入
2. 没有复杂的 JSON 解析（简单的节点/边结构）
3. 没有频繁的组件重绘

### 解决方案

#### 1. 移动 import 到函数顶部

```typescript
// ✅ 改进后
generateExcalidrawSceneStream: async (prompt) => {
  // 在函数开始时导入一次，不要在循环中
  const { safeParsePartialJson, sanitizeExcalidrawData } = await import("@/lib/excalidrawUtils");

  // ... 流式处理逻辑
  while (true) {
    // ...
    if (content.startsWith("[TOKEN]")) {
      // 不再需要 import，直接使用
      const parsed = safeParsePartialJson(jsonContent);
    }
  }
}
```

**效果**: 从 1134 次导入 → **1 次导入**

#### 2. 降低解析频率

```typescript
// ✅ 改进后
let tokenCount = 0;

if (content.startsWith("[TOKEN]")) {
  const token = content.replace("[TOKEN]", "").trimStart();
  accumulatedJson += token;
  tokenCount++;

  // 每 50 个 tokens 才解析一次
  const shouldParse = tokenCount % 50 === 0 || accumulatedJson.length % 500 < token.length;

  if (shouldParse) {
    // 解析和更新逻辑
  }
}
```

**效果**:
- 从 1134 次解析 → **约 23 次解析**
- 从 1134 次状态更新 → **约 23 次更新**

#### 3. 降低日志频率

```typescript
// ✅ 改进后
// 每 100 个 tokens 才打印一次
if (tokenCount % 100 === 0) {
  console.log(`[Streaming] Tokens: ${tokenCount}, Accumulated: ${accumulatedJson.length} chars`);
}
```

**效果**: 从 1134 行日志 → **约 11 行日志**

#### 4. 降低 UI 更新频率

```typescript
// ✅ 改进后
// 每 20 个 tokens 才更新日志显示
if (tokenCount % 20 === 0) {
  set(state => {
    const logs = [...state.generationLogs];
    if (logs.length > 0 && logs[logs.length - 1].startsWith("🤖")) {
      logs[logs.length - 1] = `🤖 Generating... (${tokenCount} tokens)`;
    } else {
      logs.push(`🤖 Generating... (${tokenCount} tokens)`);
    }
    return { generationLogs: logs };
  });
}
```

**效果**: 从 1134 次 UI 更新 → **约 57 次更新**

### 性能对比

| 操作 | 修复前 | 修复后 | 优化比例 |
|------|--------|--------|----------|
| 模块导入 | 1134 次 | 1 次 | **99.9% ↓** |
| JSON 解析 | 1134 次 | ~23 次 | **98% ↓** |
| 日志打印 | 1134 行 | ~11 行 | **99% ↓** |
| 状态更新 | 1134 次 | ~23 次 | **98% ↓** |
| UI 更新 | 1134 次 | ~57 次 | **95% ↓** |

### 效果验证

#### 修复前
```
收到 1134 tokens
→ 导入模块 1134 次
→ 解析 JSON 1134 次
→ 打印日志 1134 次
→ 更新状态 1134 次
→ 内存溢出
→ 浏览器崩溃 ❌
```

#### 修复后
```
收到 1134 tokens
→ 导入模块 1 次
→ 解析 JSON ~23 次
→ 打印日志 ~11 次
→ 更新状态 ~23 次
→ 流畅显示
→ 正常完成 ✅
```

### 关键经验

1. **永远不要在循环中使用动态 import**
   - 特别是高频循环（流式数据）
   - import 是昂贵的操作，应该在顶部一次性完成

2. **降低高频操作的执行频率**
   - 使用节流（throttle）或采样（sampling）
   - 对于流式数据，不需要处理每个 token

3. **日志也会影响性能**
   - 大量 console.log 会阻塞主线程
   - 在生产环境应该减少或关闭

4. **React 状态更新要谨慎**
   - 每次 setState 都会触发重渲染
   - 批量更新或降低频率

5. **性能测试很重要**
   - 用小数据测试可能正常，大数据就崩溃
   - FlowCanvas (159 tokens) vs Excalidraw (1134 tokens)

### 相关文件

- `frontend/lib/store/useArchitectStore.ts` (generateExcalidrawSceneStream 方法)
- `frontend/lib/excalidrawUtils.ts` (工具函数)
- `frontend/components/ExcalidrawBoard.tsx` (组件渲染)

### 预防措施

#### 开发阶段
- [ ] 添加性能监控（React Profiler）
- [ ] 测试大数据量场景（1000+ tokens）
- [ ] Code Review 检查循环中的昂贵操作
- [ ] 使用 useMemo/useCallback 优化渲染

#### 运维阶段
- [ ] 监控前端性能指标（FPS、内存使用）
- [ ] 添加流式数据大小限制
- [ ] 实现降级策略（超过阈值停止实时更新）

---

## 总结

两个问题都暴露了**容错性**和**防御性编程**的重要性：

1. **永远假设外部输入不可信**（AI 输出、用户输入）
2. **每个处理层都应该有 fallback**（解析 → 修复 → 验证 → mock）
3. **流式接口需要特别小心**（部分发送后无法撤回）
4. **TypeScript 模块导入要提前验证**（构建时检查）

下次遇到类似问题时，先检查：
- [ ] 是否有多层防御机制？
- [ ] 错误是否在合适的层级被捕获？
- [ ] Fallback 数据是否总是有效？
- [ ] 日志是否足够详细用于排查？
